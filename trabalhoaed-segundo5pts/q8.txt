using System;
using System.Collections;

namespace AED
{
    #region Classe CCelulaDup<T> - representa a célula utilizada pela classe CListaDup<T>
    /// <summary>
    /// Classe utilizada pela classe CListaDup<T>
    /// </summary>
    public class CCelulaDup<T>
    {
        public T Item; // O Item armazenado pela célula
        public CCelulaDup<T> Ant; // Referencia a célula anterior
        public CCelulaDup<T> Prox; // Referencia a próxima célula

        public CCelulaDup()
        {
            Item = default(T);
            Ant = null;
            Prox = null;
        }

        public CCelulaDup(T valorItem)
        {
            Item = valorItem;
            Ant = null;
            Prox = null;
        }

        public CCelulaDup(T valorItem, CCelulaDup<T> celulaAnt, CCelulaDup<T> proxCelula)
        {
            Item = valorItem;
            Ant = celulaAnt;
            Prox = proxCelula;
        }
    }
    #endregion

    #region Classe CListaDup<T> - Lista duplamente encadeada com célula cabeça
    /// <summary>
    /// Implementa uma lista duplamente encadeada genérica.
    /// </summary>
    public class CListaDup<T> : IEnumerable<T>
    {
        private CCelulaDup<T> Primeira; // Referencia a primeira célula da lista (célula cabeça)
        private CCelulaDup<T> Ultima; // Referencia a última célula da lista 
        private int Qtde = 0;

        public CListaDup()
        {
            Primeira = new CCelulaDup<T>();
            Ultima = Primeira;
        }

        public bool Vazia()
        {
            return Primeira == Ultima;
        }

        public void InsereFim(T valorItem)
        {
            Ultima.Prox = new CCelulaDup<T>(valorItem, Ultima, null);
            Ultima = Ultima.Prox;
            Qtde++;
        }

        public void InsereComeco(T valorItem)
        {
            if (Primeira == Ultima) // Se a lista estiver vazia insere no fim
            {
                Ultima.Prox = new CCelulaDup<T>(valorItem, Ultima, null);
                Ultima = Ultima.Prox;
            }
            else // senão insere no começo
            {
                Primeira.Prox = new CCelulaDup<T>(valorItem, Primeira, Primeira.Prox);
                Primeira.Prox.Prox.Ant = Primeira.Prox;
            }
            Qtde++;
        }

        public void RemoveComecoSemRetorno()
        {
            if (Primeira != Ultima)
            {
                Primeira = Primeira.Prox;
                Primeira.Ant = null;
                Qtde--;
            }
        }

        public void Imprime()
        {
            CCelulaDup<T> aux = Primeira.Prox;
            while (aux != null)
            {
                Console.WriteLine(aux.Item);
                aux = aux.Prox;
            }
        }

        public void ImprimeFor()
        {
            for (CCelulaDup<T> aux = Primeira.Prox; aux != null; aux = aux.Prox)
                Console.WriteLine(aux.Item);
        }

        public void ImprimeInv()
        {
            CCelulaDup<T> aux = Ultima;
            while (aux.Ant != null)
            {
                Console.WriteLine(aux.Item);
                aux = aux.Ant;
            }
        }

        public void ImprimeInvFor()
        {
            for (CCelulaDup<T> aux = Ultima; aux.Ant != null; aux = aux.Ant)
                Console.WriteLine(aux.Item);
        }

        public bool Contem(T elemento)
        {
            bool achou = false;
            CCelulaDup<T> aux = Primeira.Prox;
            while (aux != null && !achou)
            {
                achou = EqualityComparer<T>.Default.Equals(aux.Item, elemento);
                aux = aux.Prox;
            }
            return achou;
        }

        public bool ContemFor(T elemento)
        {
            bool achou = false;
            for (CCelulaDup<T> aux = Primeira.Prox; aux != null && !achou; aux = aux.Prox)
                achou = EqualityComparer<T>.Default.Equals(aux.Item, elemento);
            return achou;
        }

        public T RetornaPrimeiro()
        {
            if (Primeira != Ultima)
                return Primeira.Prox.Item;
            return default(T);
        }

        public T RetornaIndice(int Posicao)
        {
            if ((Posicao >= 1) && (Posicao <= Qtde) && (Primeira != Ultima))
            {
                CCelulaDup<T> aux = Primeira.Prox;
                for (int i = 1; i < Posicao; i++, aux = aux.Prox) ;
                if (aux != null)
                    return aux.Item;
            }
            return default(T);
        }

        public T RetornaUltimo()
        {
            if (Primeira != Ultima)
                return Ultima.Item;
            return default(T);
        }

        public void RemoveFimSemRetorno()
        {
            if (Primeira != Ultima)
            {
                Ultima = Ultima.Ant;
                Ultima.Prox = null;
                Qtde--;
            }
        }

        public void Remove(T valorItem)
        {
            if (Primeira != Ultima)
            {
                CCelulaDup<T> aux = Primeira.Prox;
                bool achou = false;
                while (aux != null && !achou)
                {
                    achou = EqualityComparer<T>.Default.Equals(aux.Item, valorItem);
                    if (!achou)
                        aux = aux.Prox;
                }
                if (achou) // achou o elemento
                {
                    CCelulaDup<T> anterior = aux.Ant;
                    CCelulaDup<T> proximo = aux.Prox;
                    anterior.Prox = proximo;
                    if (proximo != null)
                        proximo.Ant = anterior;
                    else
                        Ultima = anterior;
                    Qtde--;
                }
            }
        }

        public T RemoveRetornaComeco()
        {
            if (Primeira != Ultima)
            {
                CCelulaDup<T> aux = Primeira.Prox;
                Primeira = Primeira.Prox;
                Primeira.Ant = null;
                Qtde--;
                return aux.Item;
            }
            else
                return default(T);
        }

        public T RemoveRetornaFim()
        {
            if (Primeira != Ultima)
            {
                CCelulaDup<T> aux = Ultima;
                Ultima = Ultima.Ant;
                Ultima.Prox = null;
                Qtde--;
                return aux.Item;
            }
            else
                return default(T);
        }

        public int Quantidade()
        {
            return Qtde;
        }

        public IEnumerator<T> GetEnumerator()
        {
            for (CCelulaDup<T> aux = Primeira.Prox; aux != null; aux = aux.Prox)
                yield return aux.Item;
        }

        IEnumerator IEnumerable.GetEnumerator() => GetEnumerator();

        public IEnumerable<T> Reverse
        {
            get
            {
                for (CCelulaDup<T> aux = Ultima; aux != Primeira; aux = aux.Ant)
                    yield return aux.Item;
            }
        }
        public int primeiraOcorrenciaDe(T elemento){
            if (0 >= Qtde){
                return -1;
            }
            for (int a = 1; a <= Qtde; a++){
                if (EqualityComparer<T>.Default.Equals(RetornaIndice(a), elemento)){
                    return a;
                }
            }
            return -1;
        }
    }
    #endregion
    class Program{
        public static void Main(){
            CListaDup<int> lista = new CListaDup<int>();
            lista.InsereFim(10);
            lista.InsereFim(20);
            lista.InsereFim(30);
            lista.InsereFim(20);
            lista.InsereFim(40);
            int elementoparabuscar = 20;
            int indice = lista.primeiraOcorrenciaDe(elementoparabuscar);
            if (indice >= 0){
                Console.WriteLine("Está na posição "+indice);
            }
            else{
                Console.WriteLine("Não tem na lista");
            }
            elementoparabuscar = 80;
            indice = lista.primeiraOcorrenciaDe(elementoparabuscar);
            if (indice >= 0){
                Console.WriteLine("Está na posição "+indice);
            }
            else{
                Console.WriteLine("Não tem na lista");
            } 
            elementoparabuscar = 40;
            indice = lista.primeiraOcorrenciaDe(elementoparabuscar);
            if (indice >= 0){               
                Console.WriteLine("Está na posição "+indice);
            }
            else{
                Console.WriteLine("Não tem na lista");
            }

        }
    }
}